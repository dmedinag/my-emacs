#+TITLE:  My Emacs Configuration
#+AUTHOR: Daniel Medina
#+EMAIL:  dmedinag@protonmail.com

* Acknowledgements

After [[https://github.com/DiegoVicen][Diego]] dragged my attention over emacs,
my interest in it just started growing. Now I'm starting to use it, and
disregarding his advice I'm diving straight in org mode for my configuration
file by uncommenting the chunks I understand and want to use. This fork from his
repo is basically that: a complete copy of this guy's configuration that, over
time, will be adapted to myself. Keep on reading at your own risk, everyone's
mad here.

* Introduction

The idea generating a new configuration file using ~org-mode~ and literate
programming is taken from [[https://youtu.be/SzA2YODtgK4][Harry Schwartz's talk about org-mode]]. When Emacs is
booted, all the source blocks from this file are used to generate the
configuration file.

To do this, the only thing needed is to have the configuration file parsed and
evaluated on startup. This can be done by moving ~init.el~ to the ~emacs.d~
directory. This can be done by executing =cp init.el ~/.emacs.d/init.el= on the
terminal. Note: this file assumes that this repository has been cloned to your
home, if you are going to install it elsewhere please edit ~init.el~ to find
this file.

* Basic Emacs Setup
** My information

All the relevant and personal information that Emacs needs. If you are going to
use it, needless to say to use your own information.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Daniel Medina"
      user-mail-address "dmedinag@protonmail.com"
      calendar-latitude 40.33
      calendar-longitude -3.76
      calendar-location-name "Madrid, Spain")
#+END_SRC

** Add MELPA

The main package repository for Emacs. Must have, probably all the packages
that you need are already in MELPA. Also, check that it is HTTPS! We'll
elaborate on it in a bit.

#+BEGIN_SRC emacs-lisp
;; load emacs 24's package system. Add MELPA repository.
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   ;; '("melpa" . "http://stable.melpa.org/packages/") ; many packages won't show if using stable
   '("melpa" . "http://melpa.milkbox.net/packages/")
   t))
#+END_SRC

; ** Making Emacs secure
;
; Some safety tips regarding your editor are covered in the excellent article
; [[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][Your Text Editor is Malware]]. So, before going on with the configuration, let's
; get some things straight. First of all, enable checking trust on TLS
; connections.
;
; #+BEGIN_SRC emacs-lisp
; (setq tls-checktrust t)
; #+END_SRC
;
; Now that we have enabled this feature, Emacs can't fetch HTTPS anymore: Emacs
; does not distribute trust root certificates. So let's try to put a remedy for
; it. First, there are some things you need to install outside of Emacs: the
; ~certifi~ package for ~PyPI~ using ~python3 -m pip install --user certifi~ and
; ~gnutls~ by running ~brew install gnutls~ or ~apt-get install gnutls-bin~. Once
; we have everything set, we just need to tell Emacs where to search for the
; tools: setting the ~tls-program~ variable.
;
; #+BEGIN_SRC emacs-lisp
; ;; This snippet is ready to work in both UNIX-like and Windows OS
; (let ((trustfile
;        (replace-regexp-in-string
;         "\\\\" "/"
;         (replace-regexp-in-string
;          "\n" ""
;          (shell-command-to-string (concat "python3 -m certifi"))))))
;   (setq tls-program
;         (list
;          (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
;                  (if (eq window-system 'w32) ".exe" "") trustfile)))
;   (setq gnutls-verify-error t)
;   (setq gnutls-trustfiles (list trustfile)))
; #+END_SRC
;
; And, just in case (specially since the blog post provided it), we can create a
; function to check if this setup is properly done:
;
; #+BEGIN_SRC emacs-lisp
; (defun check-tls-config ()
;   "Check for correctness in the TLS configuration for Emacs."
;   (interactive)
;   (let ((bad-hosts
;          (cl-loop for bad
;                in `("https://wrong.host.badssl.com/"
;                     "https://self-signed.badssl.com/")
;                if (condition-case e
;                       (url-retrieve
;                        bad (lambda (retrieved) t))
;                     (error nil))
;                collect bad)))
;     (if bad-hosts
;         (error (format "TLS misconfigured; retrieved %s ok" bad-hosts))
;       (url-retrieve "https://badssl.com"
;                     (lambda (retrieved) t)))))
; #+END_SRC
;
; Please note that it is *crucial* to have added MELPA as an HTTPS for this
; secure configuration to work.

** Disable ~yes-or-no~ messages

For some reason, there are different types of confirmation prompts in
Emacs. One of them forces you to write "yes" and the other one only to press
"y", so I disable the first type.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable startup message

I simply prefer to have a scratch buffer ready when I boot up, with ~org-mode~
running. Not a great Lisp developer myself (yet).

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      initial-scratch-message nil
      initial-major-mode 'org-mode)
#+END_SRC

; ** Disable the warning when killing a buffer w/ process
;
; When a buffer (i.e ~something.py~) has an associated process (in that case,
; ~Python~ for completion), Emacs will prompt you when trying to kill it, asking
; for confirmation. I think it just interferes in my way, so I disable it as
; well.
;
; #+BEGIN_SRC emacs-lisp
; (setq kill-buffer-query-functions
;   (remq 'process-kill-buffer-query-function
;          kill-buffer-query-functions))
; #+END_SRC

** Disable the bell

It is incredibly annoying after 20 minutes.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

** Fix scroll

Setting this values will force one-line scrolling everywhere (mouse and
keyboard), resulting most of the times in a smoother scrolling than the actual
smooth scrolling.

#+BEGIN_SRC emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000
	  mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-progressive-speed nil
      mouse-wheel-follow-mouse 't)
#+END_SRC

; ** Set the backups folder
;
; This feature is super useful sometimes, but it kills me to swarm my projects
; with ~foo~~ files. That's why I set them to a backup directory and stop them
; from polluting everywhere.
;
; #+BEGIN_SRC emacs-lisp
; (setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
;   backup-by-copying t    ; Don't delink hardlinks
;   version-control t      ; Use version numbers on backups
;   delete-old-versions t  ; Automatically delete excess backups
;   kept-new-versions 20   ; how many of the newest versions to keep
;   kept-old-versions 5    ; and how many of the old
;   )
; #+END_SRC
;
; ** Fill the ~exec-path~ variable
;
; I spent too much time until I figured this out. Since I mostly use GUI Emacs,
; the ~exec-path~ variable is empty at start (it has not been started through
; shell). That's why we need a function to loading the contents of ~$PATH~ to
; Emacs variable and call it at start. This function was improved and uploaded as
; package to MELPA, so to install it:
;
; #+BEGIN_SRC emacs-lisp
; (use-package exec-path-from-shell
;   :ensure t
;   :demand t
;   :config (when (memq window-system '(mac ns x))
;             (exec-path-from-shell-initialize)
;             (add-hook 'find-file-hook 'exec-path-from-shell-initialize)))
; #+END_SRC

** Insert new line without breaking

One of the things I really miss from vim is the shortcut ~o~, which was used to
insert a new line below the line in which the cursor is. To have the same
behavior in Emacs, I found this custom function that I bound to ~C-o~.

#+BEGIN_SRC emacs-lisp
(defun insert-new-line-below ()
  "Add a new line below the current line"
  (interactive)
  (let ((oldpos (point)))
    (end-of-line)
    (newline-and-indent)))

(global-set-key (kbd "C-o") 'insert-new-line-below)
#+END_SRC

; ** Move buffers around
;
; If we want to swap buffers location in frames, there's no fast way to do it in
; Emacs by default. To do it, a good option that I found is to use ~buffer-move~
; package, and use these key bindings.
;
; #+BEGIN_SRC emacs-lisp
; (use-package buffer-move
;   :ensure t
;   :bind (("C-x w <up>"    . buf-move-up)
;          ("C-x w <down>"  . buf-move-down)
;          ("C-x w <left>"  . buf-move-left)
;          ("C-x w <right>" . buf-move-right)))
; #+END_SRC

** Redefining sentences in Emacs

Emacs allows you to move in sentences using the commands ~M-a~ and ~M-e~ (to go
to the beginning or the end of the sentence). This is super useful for editing
text, but Emacs assumes that you always end sentences using a period and /two/
whitespaces, which... I actually don't. We can override this behavior with:

#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)
#+END_SRC

** Auto-fill comments

For our comments (only comments, not code) to be automatically filled
in programming modes, we can use this function:

#+BEGIN_SRC emacs-lisp
(defun comment-auto-fill ()
      (setq-local comment-auto-fill-only-comments t)
      (auto-fill-mode 1))

(add-hook 'prog-mode-hook 'comment-auto-fill)
#+END_SRC

** Increase or decrease font size across all buffers

Extracted from a file in [[https://github.com/purcell/emacs.d][Steve Purcell's Emacs configuration]], it is possible to
use this functions to increase or decrease the text scale in all Emacs.
Specially useful for presentations, demos and other shows alike.

#+BEGIN_SRC emacs-lisp
(defun font-name-replace-size (font-name new-size)
  (let ((parts (split-string font-name "-")))
    (setcar (nthcdr 7 parts) (format "%d" new-size))
    (mapconcat 'identity parts "-")))

(defun increment-default-font-height (delta)
  "Adjust the default font height by DELTA on every frame.
The pixel size of the frame is kept (approximately) the same.
DELTA should be a multiple of 10, in the units used by the
:height face attribute."
  (let* ((new-height (+ (face-attribute 'default :height) delta))
         (new-point-height (/ new-height 10)))
    (dolist (f (frame-list))
      (with-selected-frame f
        ;; Latest 'set-frame-font supports a "frames" arg, but
        ;; we cater to Emacs 23 by looping instead.
        (set-frame-font (font-name-replace-size (face-font 'default)
                                                new-point-height)
                        t)))
    (set-face-attribute 'default nil :height new-height)
    (message "default font size is now %d" new-point-height)))

(defun increase-default-font-height ()
  (interactive)
  (increment-default-font-height 10))

(defun decrease-default-font-height ()
  (interactive)
  (increment-default-font-height -10))

(global-set-key (kbd "C-M-=") 'increase-default-font-height)
(global-set-key (kbd "C-M--") 'decrease-default-font-height)
#+END_SRC

; ** More intuitive regions
;
;
; This makes the visual region behave more like the contemporary concept of
; highlighted text, that can be erased or overwritten as a whole.
;
; #+BEGIN_SRC emacs-lisp
; (delete-selection-mode t)
; #+END_SRC
;
** Add functions to determine system

To know in which system we are running, I use these functions:

#+BEGIN_SRC emacs-lisp
(defun system-is-mac ()
  (interactive)
  (string-equal system-type "darwin"))

(defun system-is-linux ()
  (interactive)
  (string-equal system-type "gnu/linux"))

(defun system-is-chip ()
  (interactive)
  (string-equal system-name "chip"))
#+END_SRC

; ** Define keybindings to ~eval-buffer~ on init and open ~README.org~
;
; Before this magical ~org~ configuration, it was easier to reload Emacs
; configuration on the fly: ~M-x eval-buffer RET~. However, now the buffer to
; evaluate is not this one, but ~.emacs.d/init.el~. That's why it's probably a
; better idea to define a new keybinding that automatically reloads that buffer.
;
; #+BEGIN_SRC emacs-lisp
; (defun reload-emacs-configuration()
;   "Reload the configuration"
;   (interactive)
;     (load "~/.emacs.d/init.el"))
;
; (defun open-emacs-configuration ()
;   "Open the configuration.org file in buffer"
;   (interactive)
;     (find-file "~/my-emacs/README.org"))
;
; (global-set-key (kbd "C-c c r") 'reload-emacs-configuration)
; (global-set-key (kbd "C-c c o") 'open-emacs-configuration)
; #+END_SRC

** Scroll in the compilation buffer

It is really annoying to not have the last part of the output in the screen
when compiling. This automatically scrolls the buffer for you as the output is
printed.

#+BEGIN_SRC emacs-lisp
(setq compilation-scroll-output t)
#+END_SRC

; ** Add other keybindings
;
; Miscellaneous keybindings that don't really fit anywhere else.
;
; #+BEGIN_SRC emacs-lisp
; (global-set-key (kbd "C-c b") 'bookmark-jump)
; (global-set-key (kbd "M-j") 'mark-word)
; #+END_SRC
;
; * My own Emacs-Lisp functions
; ** Clean the buffer
;
; This function cleans the buffer from trailing whitespaces, more than two
; consecutive new lines and tabs.
;
; #+BEGIN_SRC emacs-lisp
; (defun my-clean-buffer ()
;   "Cleans the buffer by re-indenting, removing tabs and trailing whitespace."
;   (interactive)
;   (delete-trailing-whitespace)
;   (save-excursion
;     (replace-regexp "^\n\\{3,\\}" "\n\n" nil (point-min) (point-max)))
;   (untabify (point-min) (point-max)))
;
; (global-set-key (kbd "C-c x") 'my-clean-buffer)
; #+END_SRC
;
; ** Move to indentation or beginning of the line
;
; By default, ~C-c a~ moves the cursor to the beginning of the line. If there is
; indentation, usually you want to move to the beginning of the line after the
; indentation, which is indeed bound by default to ~M-m~. However, my muscle
; memory seems to be unable to learn that those are two different actions, so
; it's time to use some Emacs magic. ~beginning-of-line-dwim~ takes you to the
; beginning of indentation, as ~M-m~ would do. If you are already there, it takes
; you to the absolute beginning of the line.
;
; #+BEGIN_SRC emacs-lisp
; (defun beginning-of-line-dwim ()
;   (interactive)
;   "Move to beginning of indentation, if there move to beginning of line."
;   (if (= (point) (progn (back-to-indentation) (point)))
;       (beginning-of-line)))
;
; (global-set-key (kbd "C-a") 'beginning-of-line-dwim)
; #+END_SRC

** Set the fringe as the background

This function allows to set the fringe color the same as the background, which
makes it look flatter and more minimalist.

#+BEGIN_SRC emacs-lisp
(defun set-fringe-as-background ()
  "Force the fringe to have the same color as the background"
  (set-face-attribute 'fringe nil
                      :foreground (face-foreground 'default)
                      :background (face-background 'default)))
#+END_SRC

** Change light and dark themes

Since I don't simply load a theme, but a lot of customization along with it, I
need to load the different themes in whole functions. That way, when I want to
switch from one to the other, I prevent the hand-tuned things to crash.

#+BEGIN_SRC emacs-lisp
(defun load-common-setup ()
  "Set all the faces that are prepared for both light and dark themes"
  (set-face-foreground 'git-gutter:modified "#fabd2f")
  (set-face-foreground 'git-gutter:added    "#b8bb26")
  (set-face-foreground 'git-gutter:deleted  "#fb4933")
  (set-face-attribute 'font-lock-doc-face nil :inherit 'shadow)
  (set-face-attribute 'org-ellipsis nil :underline nil)
  (set-fringe-as-background))

(defun load-dark-theme ()
  "Load the theme gruvbox-dark-medium and other custom faces."
  (interactive)
  (load-theme 'gruvbox-dark-medium t)
  (load-common-setup)
  (set-face-foreground 'shadow "#a89984")
  (set-face-attribute 'mode-line nil
                      :box '(:line-width 5 :color "#665c54"))
  (set-face-attribute 'mode-line-inactive nil
                      :box '(:line-width 5 :color "#3c3836"))
  (org-bullets-mode)
  (org-bullets-mode))

(defun load-light-theme ()
  "Load the theme gruvbox-light-medium and other custom faces."
  (interactive)
  (load-theme 'gruvbox-light-soft t)
  (load-common-setup)
  (set-face-foreground 'shadow "#7c6f64")
  (set-face-attribute 'mode-line nil
                      :box '(:line-width 5 :color "#bdae93"))
  (set-face-attribute 'mode-line-inactive nil
                      :box '(:line-width 5 :color "#ebdbb2"))
  (org-bullets-mode)
  (org-bullets-mode))

(global-set-key (kbd "C-c c d") 'load-dark-theme)
(global-set-key (kbd "C-c c l") 'load-light-theme)
#+END_SRC

; ** A twist on killing lines
;
; I have the strange (and probably detrimental) muscle memory of using
; ~kill-line~ as a fast method for copying and pasting. However, this implies
; that I find myself far too often using ~C-k C-y~. For that reason, I just
; wanted to merge these two options in a single keystroke. I bind it to ~M-k~
; because I usually don't move in sentences and I definitely don't kill
; sentences; your mileage may vary.
;
; #+BEGIN_SRC emacs-lisp
; (defun dont-kill-line()
;   "Copy fromm the point to the end of the line without deleting it."
;   (interactive)
;   (kill-line)
;   (yank))
;
; (global-set-key (kbd "M-k") 'dont-kill-line)
; #+END_SRC
;
* Graphical Interface
** Disabling GUI defaults

I always use Emacs in its GUI client, but because of the visual capabilities
and not the tools and bars. That's why I like to disable all the graphical
clutter.

The first line disables the menu bar, but it is commented to allow the full
screen behavior in macOS.

#+BEGIN_SRC emacs-lisp
(if (not (system-is-mac)) (menu-bar-mode -1))

(tool-bar-mode -1)
(scroll-bar-mode 1)
#+END_SRC

; ** Start in full-screen
;
; If we are running on Mac, this snippet launches the native fullscreen; if not
; it just maximizes the first frame we create.
;
; #+BEGIN_SRC emacs-lisp
; ;(if (system-is-mac) (toggle-frame-fullscreen))
; ;    (set-frame-parameter nil 'fullscreen 'fullboth)
; ;  (setq initial-frame-alist '((fullscreen . maximized))))
; #+END_SRC
;
** Setting default font

#+BEGIN_SRC emacs-lisp
(set-default-font "hasklig 13" t t)
#+END_SRC
;
; I really like how condensed is [[https://github.com/be5invis/Iosevka][Iosevka]], a coding typeface. Although it may look
; weird in the beginning, then it's a joy to have all your code properly fitting
; in the screen. However, lately I have really been into Liberation Mono, Fira
; Mono, Office Code Pro and Roboto Mono. All great, readable fonts.
;
; #+BEGIN_SRC emacs-lisp
; (if (system-is-chip)
;     (set-default-font "Liberation Mono 8" t t)
;   (if (system-is-mac)
;       (set-default-font "Roboto Mono 13" t t)
;     (set-default-font "Roboto Mono 11" t t)))
;
; ;; (set-default-font "Office Code Pro 13" t t))
; #+END_SRC

** Highlight changed and uncommited lines

Use the ~git-gutter-fringe~ package for that. For me it's more than enough to
have it in programming modes and in ~org-mode~.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :ensure git-gutter-fringe
  :delight
  :config
  (add-hook 'prog-mode-hook 'git-gutter-mode)
  (add-hook 'org-mode-hook 'git-gutter-mode))
#+END_SRC

Since we are using Gruvbox theme all along, I prefer to tweak the colors to
make them softer, using some red, green and yellow from the color palette.

** ~delight~ to manage mode names in the mode-line

This package let us rename or hide mode names in the mode-line, with the great
advantage of being fully compatible with ~use-package~.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :ensure t
  :demand t)
#+END_SRC

Since Emacs provides some minor modes that I want to hide as well, we will add
a weird declaration to maintain the coherence:

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :delight
  (auto-revert-mode)
  (auto-fill-function)
  (visual-line-mode))
#+END_SRC

** Setting my favorite theme

I really like [[https://github.com/chriskempson/base16][base16 color themes]] by Chris Kempson, specially Eighties.
However, lately I am really enjoying Gruvbox themes lately. They are available
in MELPA. We also use the ~NO-CONFIRM~ flag when loading, since the file
tangling probably makes the code be not in order for ~custom-set-variables~ to
do its job.

#+BEGIN_SRC emacs-lisp
(use-package gruvbox-theme
  :ensure t
  :config (load-dark-theme))
#+END_SRC

; ** ~smart-mode-line~ configuration
;
; ~smart-mode-line~ allows us to do a greater configuration of the mode-line
; without being as flashy (and accessible tbh). This is the bare-bones
; configuration for the package, that makes it not even load a theme. Apart from
; the mere aesthetics, I also configure the column number display and different
; short names for my folders. The last part edits slightly the mode line by
; adding a single white-space below the fringe, which helps when rendering.
;
; #+BEGIN_SRC emacs-lisp
; (use-package smart-mode-line
;   :ensure t
;   :config
;   (progn
;     ;; Basic
;     (setq sml/theme nil)
;     (sml/setup)
;     (setq sml/no-confirm-load-theme t)
;     ;; Format the line string
;     (setq-default mode-line-format
;       '(" %e"
;         mode-line-front-space
;         mode-line-mule-info
;         mode-line-client
;         mode-line-modified
;         mode-line-remote
;         mode-line-frame-identification
;         mode-line-buffer-identification
;         sml/pos-id-separator
;         mode-line-position
;         (vc-mode vc-mode)
;         sml/pre-modes-separator
;         mode-line-modes
;         mode-line-misc-info
;         mode-line-end-spaces))
;     ;; Shorthands and column number
;     (column-number-mode 1)
;     (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/" ":DB:"))
;     (add-to-list 'sml/replacer-regexp-list '("^~/Projects/" ":PRJ:"))
;     (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/org/" ":ORG:" ))
;     (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/org/bibliography/"
;                                              ":BIB:" ))
;     ))
; #+END_SRC
;
; ** Configure modes in mode line to be shorter
;
; ~cyphejor~ is a package that allows to make shorter names in the
; mode-line. And, as you can see, my way to use it is maybe a little bit
; aggressive.
;
; #+BEGIN_SRC emacs-lisp
; (use-package cyphejor
;   :ensure t
;   :config
;   (progn
;     (setq
;      cyphejor-rules
;      '(:upcase
;        ("bookmark"    "→")
;        ("buffer"      "β")
;        ("diff"        "Δ")
;        ("dired"       "δ")
;        ("emacs"       "ε")
;        ("fundamental" "Ⓕ")
;        ("inferior"    "i" :prefix)
;        ("interaction" "i" :prefix)
;        ("interactive" "i" :prefix)
;        ("lisp"        "λ" :postfix)
;        ("menu"        "▤" :postfix)
;        ("haskell"     "λ=")
;        ("mode"        "")
;        ("package"     "↓")
;        ("python"      "π")
;        ("org"         "Ω")
;        ("shell"       "sh" :postfix)
;        ("text"        "ξ")))
;     (cyphejor-mode 1)))
; #+END_SRC
;
** Set the cursor as a vertical bar

This is less agressive than the default brick, for sure. Thanks [[https://github.com/Alexrs95][Alex]] for this
snippet!

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

** Adding icons with ~all-the-icons~

This package comes with a set of icons gathered from different fonts, so they
can be used basically everywhere. At least in macOS, remember to install the
necessary fonts that come bundled in the package!

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)
#+END_SRC

; * Packages & Tools
; ** ~which-key~
;
; A beautiful package that helps a lot specially when you are new to Emacs. Every
; time a key chord is started, it displays all possible outcomes in the
; minibuffer.
;
; #+BEGIN_SRC emacs-lisp
; (use-package which-key
;   :delight
;   :ensure t
;   :config (which-key-mode))
; #+END_SRC
;
; ** ~dired~
;
; Emacs' default directory system. It may feel weird first, but it is super
; powerful. Its main feature is that it is a buffer. Yes, ok, everything is a
; buffer in Emacs, but if you press ~C-c C-q~ in a dired buffer it turns into a
; writeable buffer, so you can edit the directory files just as a regular Emacs
; piece of text! I also like to have the details hidden. Also, I feel like it can
; be useful to comment a bit on ~dired-dwim-target~. This enables the dired's Do
; What I Mean behavior, which means that if you try to rename a file with a
; second buffer open, it will assume that you want to move it there. Same with
; copy and other operations.
;
; #+BEGIN_SRC emacs-lisp
; (add-hook 'dired-mode-hook 'dired-hide-details-mode)
; (setq dired-dwim-target t)
; #+END_SRC
;
; ** ~neotree~
;
; I used the default ~dired~ for a long time, but I found that ~neotree~ adds
; less clutter normally. I also set the theme for the icons using
; ~all-the-icons~. Since I have already the muscle memory, I just override
; ~dired~'s regular binding to open ~neotree~.
;
; #+BEGIN_SRC emacs-lisp
; (use-package neotree
;   :delight
;   :ensure t
;   :config (setq neo-theme (if (display-graphic-p) 'icons 'arrow)))
; #+END_SRC
;
; ** ~ivy~
;
; After trying ~ido~ and ~helm~, the only step left to try was ~ivy~. The way it
; works is more similar to ~ido~: it is a completion engine but more minimalist
; than ~helm~, simpler and faster.
;
; #+BEGIN_SRC emacs-lisp
; (use-package ivy
;   :ensure t
;   :demand t
;   :delight
;   :config
;   (ivy-mode 1)
;   (setq ivy-use-virtual-buffers t
;         ivy-count-format "%d/%d ")
;
;   :bind (("C-s" . swiper)
;          ("C-c h f" . counsel-describe-function)
;          ("C-c h v" . counsel-describe-variable)
;          ("M-i" . counsel-imenu)
;          :map ivy-minibuffer-map
;          ("RET" . ivy-alt-done)
;          ("C-j" . ivy-done)))
; #+END_SRC
;
; Apart from ~ivy~, I also like to use other alternative packages that complement
; it.
;
; #+BEGIN_SRC emacs-lisp
; (use-package ivy-rich
;   :ensure t
;   :demand t
;   :config
;   (ivy-set-display-transformer 'ivy-switch-buffer
;                                'ivy-rich-switch-buffer-transformer)
;   )
; #+END_SRC
;
; ** ~iy-go-to-char~
;
; Mimic vim's ~f~ with this function. I bind it to ~M-m~ to because the default
; function in there (~beginning-of-indentation~) is not necessary after adding
; ~beginning-of-line-dwim~.
;
; #+BEGIN_SRC emacs-lisp
; (use-package iy-go-to-char
;   :ensure t
;   :demand t
;   :bind (("M-m" . iy-go-up-to-char)
;          ("M-M" . iy-go-to-char)))
; #+END_SRC

** ~ws-butler~

Remove the trailing whitespaces from the lines that have been edited. The point
of removing only the ones from the lines edited is to preserve useful blames
and diffs in VCS.

#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :ensure t
  :delight
  :config (ws-butler-global-mode 1))
#+END_SRC

; ** ~magit~
;
;
; A porcelain client for git. ~magit~ alone is a reason to use Emacs over
; vi/vim. It is really wonderful to use and you should install right now. This
; also binds the status function to ~C-x g~.
;
; #+BEGIN_SRC emacs-lisp
; (use-package magit
;   :delight
;   :ensure t
;   :bind (("C-x g" . magit-status)))
; #+END_SRC

; ** ~projectile~
;
; Enables different tools and functions to deal with files related to a
; project. To work, it searches for a VCS and sets it as the root of a project. I
; have it configured to ignore all files that has not been staged in the git
; project.
;
; #+BEGIN_SRC emacs-lisp
; (use-package projectile
;   :ensure t
;   :delight
;   :config
;   (projectile-global-mode 1)
;   (setq projectile-use-git-grep t))
; #+END_SRC
;
; Also, the extension ~counsel-projectile~ adds integration with ~ivy~.
;
; #+BEGIN_SRC emacs-lisp
; (use-package counsel-projectile
;   :ensure t
;   :delight
;   :config (counsel-projectile-mode t))
; #+END_SRC
;
; ** ~perspective~
;
; This package lets us store the window distributions that we use and switch
; between them. I like to use it with ~persp-projectile~, which creates
; perspectives automatically integrating them with each project. To configure it:
;
; #+BEGIN_SRC emacs-lisp
;   ;; (use-package perspective
;   ;;   :ensure t
;   ;;   :demand t
;   ;;   :delight
;   ;;   :config
;   ;;   (persp-mode)
;   ;;   :bind (:map projectile-mode-map
;   ;;              ("C-c p f" . counsel-git)
;   ;;              ("C-c p n" . persp-next)
;   ;;              ("C-c p k" . kill-current-perspective)))
;
;   ;; (use-package persp-projectile
;   ;;   :ensure t
;   ;;   :demand t)
; #+END_SRC
;
; This snippet also changes the color of the mode-line widget to a smoother one
; and binds ~C-c p n~ to change next perspective to integrate better the
; perspective and project management.
;
; Now that we have defined this beautiful ~perspective~ + ~projectile~ combo, we
; can tweak a bit more its integration: For example, we can override the
; behavior of ~C-c p k~: by default it is ~projectile-kill-buffers~, that will
; kill all buffers associated to a project. We can make it also delete the
; associated perspective:
;
; #+BEGIN_SRC emacs-lisp
; (defun kill-current-perspective ()
;   "Kill the current project buffers and close its perspective."
;   (interactive)
;   (persp-kill (persp-name persp-curr)))
; #+END_SRC
;
; It is important to use ~define-key~ to shadow ~projectile~'s own bindings.
;
; ** ~flycheck~
;
; Checks syntax for different languages. Works wonders, even though sometimes has
; to be configured because it really makes things slow.
;
; #+BEGIN_SRC emacs-lisp
; (use-package flycheck
;   :ensure t
;   :delight
;   :config
;   (add-hook 'prog-mode-hook #'flycheck-mode)
;   (set-face-underline 'flycheck-error '(:color "Red1" :style line)))
; #+END_SRC
;
; ** ~flyspell~
;
; Just like ~flycheck~, but it checks natural language in a text. Super useful
; for note taking and other text edition, specially if you use Emacs for
; everything like I do. ~flyspell~ is installed in new Emacs versions, but there
; are no completion tools by default in macOS, so we need to install the ~aspell~
; engine by running ~brew install aspell --with-lang-en~
;
; To make ~flyspell~ not clash with different syntax in the same file (like for
; example, LaTeX or ~org-mode~ one) we need the last hook message.
;
;
; #+BEGIN_SRC emacs-lisp
; (use-package flyspell
;   :ensure t
;   :delight
;   :config
;   (progn
;     (setq ispell-program-name "aspell"
;           ispell-dictionary "english")
;     (add-hook 'org-mode-hook (lambda () (setq ispell-parser 'tex)))))
; #+END_SRC
;
; In case I am writing a text in a different language, I can just use ~M-x
; ispell-change-dictionary~. Emacs seems to have a wide enough range of
; dictionaries preinstalled to suit my needs. Later in the configurations, hooks
; are added to each of the major-modes where I want ~flyspell~ to work.
;
; And this function prevents the spell checker to get inside source blocks in
; ~org~.
;
; #+BEGIN_SRC emacs-lisp
; (defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
;   (let* ((rlt ad-return-value)
;          (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
;          (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
;          (case-fold-search t)
;          b e)
;     (when ad-return-value
;       (save-excursion
;         (setq b (re-search-backward begin-regexp nil t))
;         (if b (setq e (re-search-forward end-regexp nil t))))
;       (if (and b e (< (point) e)) (setq rlt nil)))
;     (setq ad-return-value rlt)))
; #+END_SRC

** ~company~

It is a light-weight completion system, supposed to be faster and simpler than
good 'ol ~auto-complete~.

#+BEGIN_SRC emacs-lisp
(use-package company
  :delight
  :ensure t
  :config (setq company-tooltip-align-annotations t))
#+END_SRC

; ** ~auto-complete~
;
; It is probably redundant with ~company~, but works like a charm for the Python
; environment. This bare-bones config just enables auto completion for language
; specific words and other words in the buffer, so it's not really super useful.
; For language specific settings, check each of the langauge configs. Also, I
; like to customize a bit the looks of the pop-up menu
;
; #+BEGIN_SRC emacs-lisp
; ;; (use-package auto-complete-config
; ;;   :disabled
; ;;   :ensure auto-complete
; ;;   :config
; ;;   (progn
; ;;     (ac-config-default)
; ;;     (setq ac-show-menu-immediately-on-auto-complete t)
; ;;     (set-face-attribute 'popup-summary-face nil :inherit 'popup-face)
; ;;     (set-face-attribute 'popup-tip-face nil
; ;;                         :foreground "#c0c5ce"
; ;;                         :background "#4f5b66")))
; #+END_SRC
;
; ** ~smartparens~
;
; Auto-close parenthesis and other characters. Useful as it seems. Also, I add a
; new custom pair that makes it indent and pass the closing pair when a newline
; is inserted right after a curly bracket. This is specially useful in C and Go.
;
; #+BEGIN_SRC emacs-lisp
; (use-package smartparens
;   :ensure t
;   :delight
;   :config
;   (add-hook 'prog-mode-hook #'smartparens-mode)
;   (sp-pair "{" nil :post-handlers '(("||\n[i]" "RET"))))
; #+END_SRC
;
; ** ~expand-region~
;
; Expand region allows to select hierarchically different text regions. It is, in
; a way, a replacement for vim text objects.
;
; #+BEGIN_SRC emacs-lisp
; (use-package expand-region
;   :ensure t
;   :delight
;   :bind (("C-=" . er/expand-region)))
; #+END_SRC
;
; ** ~eshell~
;
; I don't use shell as much as I did before customizing Emacs, but still a good
; command line is the best option sometimes. Bound it to ~C-c t~ and use all the
; shortcuts of Emacs inside of it!
;
; #+BEGIN_SRC emacs-lisp
; (global-set-key (kbd "C-c t") 'eshell)
; #+END_SRC
;
; I also configure a company back-end to get =fish=-like completion, that
; provides suggestions based on previous commands.
;
; #+BEGIN_SRC emacs-lisp
; (use-package esh-autosuggest
;   :hook (eshell-mode . esh-autosuggest-mode)
;   :ensure t)
; #+END_SRC
;
; ** ~iedit~
;
; This tool allows us to edit all variable names at once just by entering a
; single keystroke.
;
; #+BEGIN_SRC emacs-lisp
; (use-package iedit
;   :ensure t
;   :delight
;   :bind (("C-c i" . iedit-mode)))
; #+END_SRC
;
; ** ~easy-escape~
;
; Makes Lisp regular expressions more readable.
;
; #+BEGIN_SRC emacs-lisp
; (use-package easy-escape
;   :ensure t
;   :delight
;   :config
;   (progn
;     (add-hook 'lisp-mode-hook 'easy-escape-minor-mode)
;     (add-hook 'emacs-lisp-mode-hook 'easy-escape-minor-mode)
;     ))
; #+END_SRC
;
; ** ~undo-tree~
;
; This awesome package enables a gret undo-redo system that includes creating new
; undo-redo branches. It's really amazing.
;
; #+BEGIN_SRC emacs-lisp
; (use-package undo-tree
;   :ensure t
;   :delight
;   :config (global-undo-tree-mode))
; #+END_SRC
;
; ** ~yasnippets~
;
; This package is a template and snippet system for Emacs, inspired by the syntax
; of TextMate.
;
; #+BEGIN_SRC emacs-lisp
; (use-package yasnippet
;   :ensure t
;   :delight
;   :config
;   (progn
;     (add-to-list 'yas-snippet-dirs "~/my-emacs/snippets")
;     (yas-global-mode 1)
;     (advice-add 'yas--auto-fill-wrapper :override #'ignore)))
; #+END_SRC
;
; In the ~/snippets~ folder in this repository you can see my snippets
; collection. A good guide to understand the syntax used is in [[https://joaotavora.github.io/yasnippet/snippet-development.html][the manual for
; YASnippet]]. All the snippets are local to a certain mode (delimited by the name
; of the folder in the collection) and their keys can be expanded using ~TAB~.
;
; ** Rainbow delimiters
;
; This package turns the parenthesis into color pairs, which makes everything
; easier (specially in Lisp)
;
; #+BEGIN_SRC emacs-lisp
; (use-package rainbow-delimiters
;   :ensure t
;   :delight
;   :config (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
; #+END_SRC
;
* Programming Modes
** Python
*** Regular Python configuration

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :delight
  :config
  (elpy-enable)
  (add-to-list 'python-shell-completion-native-disabled-interpreters "ipython")
  (setq python-shell-interpreter "ipython"
		python-shell-interpreter-args "-i --simple-prompt")
  (add-hook 'elpy-mode-hook (lambda () (highlight-indentation-mode -1))))
#+END_SRC

; *** Notebook configuration
;
; #+BEGIN_SRC emacs-lisp
; (use-package ein
;   :ensure t
;   :config (add-hook 'ein:notebook-multilang-mode-hook 'visual-line-mode))
; #+END_SRC
;
; ** Haskell
; *** Enable ~intero~
;
; In my experience, trying to deal with ~haskell-mode~ head-on is a pain in the
; ass, and makes programming really slow. However, ~intero~ is a package with
; batteries-included that works wonders. The best idea is to install it and hook
; it to Haskell.
;
; #+BEGIN_SRC emacs-lisp
; (use-package intero
;   :ensure t
;   :init   (setenv "PATH" (concat "/usr/local/bin/ghci" (getenv "PATH")))
;   :config (add-hook 'haskell-mode-hook 'intero-mode))
; #+END_SRC
;
; *** Disable soft wrapping in profiling files
;
; GHC generates ~.prof~ files, which sometimes tend to have really long lines. To
; make it easier to read them, I like to disable line truncation for that file
; extension. The problem is that, well, is not as straightforward as you may
; think...
;
; #+BEGIN_SRC emacs-lisp
; (add-hook 'find-file-hook
;           (lambda ()
;             (when (and (stringp buffer-file-name)
;                        (string-match "\\.prof\\'" buffer-file-name))
;               (toggle-truncate-lines))))
; #+END_SRC
;
; ** Idris
;
; Idris is a relatively new language: purely functional, general purpose, and
; oriented to type development and with a type and totality checker integrated. I
; think that it is a super interesting experiment but a good Emacs configuration
; makes it look like absolute magic.
;
; #+BEGIN_SRC emacs-lisp
; (use-package idris-mode
;   :delight
;   :ensure t
;   :bind (:map idris-mode-map
;               ("C-c C-a" . idris-add-clause)
;               ("C-c C-s" . idris-case-split)
;               ("C-c C-f" . idris-proof-search)))
; #+END_SRC
;
; With this config, we can use a type-define-refine cycle by using the keys =C-c
; C-a= to add a clause associated with a type definition, =C-c C-s= to split
; cases and =C-c C-f= to fill a hole if possible; which is easier for me to
; remember.
;
; ** Go
;
; I am a complete noob in Go, and I have been trying to hack a bit with it
; lately. This is just a little disclaimer taking into account that this is just
; a leisure configuration and if you are going to manage code on production maybe
; you need a different configuration to face it.
;
; *** Installing and configuring ~go-mode~
;
; The first recommendation for a Go major mode seems to be this one:
;
; #+BEGIN_SRC emacs-lisp
; (use-package go-mode
;   :ensure t)
; #+END_SRC
;
; *** Set tab width
;
; Since Go is not precisely characterized by its open-mindedness, we have to use
; tabs in our code (sigh). So, at least, let's set its size to something that can
; be read (4 instead 8 characters long)
;
; #+BEGIN_SRC emacs-lisp
; (setq-default tab-width 4)
; #+END_SRC
;
; *** Calling ~go-fmt~ on save
;
; We can use hooks to automatically format our code according to the guidelines:
;
; #+BEGIN_SRC emacs-lisp
; (add-to-list 'exec-path "/Users/diego/go")
; (add-hook 'before-save-hook 'gofmt-before-save)
; #+END_SRC
;
; *** Adding the ~company~ backend
;
; Making auto-completion work in Go requires:
;
; #+BEGIN_SRC emacs-lisp
; (use-package company-go
;   :ensure t
;   :config
;   (add-hook 'go-mode-hook 'company-mode)
;   (add-to-list 'company-backends 'company-go))
; #+END_SRC
;
; *** Viewing documentation in the minibuffer
;
; Using ~go-eldoc~ we can see the declaration, arguments, return types, etc of
; the functions we are using in our code.
;
; #+BEGIN_SRC emacs-lisp
; (use-package go-eldoc
;   :ensure t
;   :config (add-hook 'go-mode-hook 'go-eldoc-setup))
; #+END_SRC
;
; *** Enabling playgrounds in Emacs
;
; Go playgrounds enable a kind of REPL, which is super useful when trying to
; learn the language and fast iterate over some code snippets.
;
; #+BEGIN_SRC emacs-lisp
; (use-package go-playground
;   :ensure t)
; #+END_SRC
;
; ** Rust
;
; More or less like Go's one, this is just a minimal configuration for the
; language.
;
; *** Basic major mode
;
; #+BEGIN_SRC emacs-lisp
; (use-package rust-mode
;   :ensure t
;   :config (setq rust-format-on-save t))
; #+END_SRC
;
; *** Enable ~flycheck~
;
; #+BEGIN_SRC emacs-lisp
; (use-package flycheck-rust
;   :ensure t
;   :demand t
;   :config (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
; #+END_SRC
;
; *** Enable the ~company~ backend
;
; #+BEGIN_SRC emacs-lisp
; (use-package racer
;   :ensure t
;   :demand t
;   :config
;   (add-hook 'rust-mode-hook #'racer-mode)
;   (add-hook 'racer-mode-hook #'eldoc-mode)
;   (add-hook 'racer-mode-hook #'company-mode)
;   :bind (:map rust-mode-map
;               ("TAB" . company-indent-or-complete-common)))
; #+END_SRC
;
; ** LaTeX
;
; With this configuration, we try to aim for a WYSIWYG editor in Emacs. It
; requires to have ~AUCTeX~ installed.
;
; *** Basic ~AUCTeX~ setup
;
; This snippet makes that the ~AUCTeX~ macros are loaded every time the editor
; requires them.
;
; #+BEGIN_SRC emacs-lisp
; (setq TeX-auto-save t)
; (setq TeX-parse-self t)
; (setq TeX-save-query nil)
; (setq-default TeX-master nil)
; ;(setq TeX-PDF-mode t)
; #+END_SRC
;
; *** Enable ~flyspell~ in Tex edition
;
; Add the hook to enable it by default.
;
; #+BEGIN_SRC emacs-lisp
; (add-hook 'LaTeX-mode-hook 'flyspell-mode)
; (add-hook 'LaTeX-mode-hook 'flyspell-buffer)
; #+END_SRC
;
; *** Enable auto-fill for Tex edition
;
; We already enabled auto-fill for comments in programming modes, but in LaTeX is
; more useful to directly have everything auto-filled.
;
; #+BEGIN_SRC emacs-lisp
; (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
; #+END_SRC
;
; *** Adding ~company~ support for Tex
;
; Add the backend enable auto-completion for LaTeX files.
;
; #+BEGIN_SRC emacs-lisp
; (use-package company-auctex
;   :ensure t
;   :config
;   (add-hook 'LaTeX-mode-hook 'company-mode)
;   (company-auctex-init))
; #+END_SRC
;
; * ~org-mode~
; ** Basic setup and other habits
; *** Enable ~auto-fill-mode~ in Emacs
;
; I truly believe that code and other text files have to respect a 79 characters
; per line bound. No, 120 is not enough. Of course, for me ~org-mode~ should also
; be, so we enable this behaviour to be automatic. Also, keep in mind that Emacs
; auto fills to 70 characters, so we have to manually set the 79 limit.
;
; #+BEGIN_SRC emacs-lisp
; (add-hook 'org-mode-hook 'auto-fill-mode)
; (setq-default fill-column 79)
; #+END_SRC
;
; *** Ensure LaTeX export options
;
; We need to ensure that the indentation is left unaltered when exporting to
; LaTeX, and also to add several options for ~org-ref~ exporting to work properly
;
; #+BEGIN_SRC emacs-lisp
; (setq org-src-preserve-indentation t)
;
; (setq org-latex-default-packages-alist
;       (-remove-item
;        '("" "hyperref" nil)
;        org-latex-default-packages-alist))
;
; (add-to-list 'org-latex-default-packages-alist '("" "natbib" "") t)
; (add-to-list 'org-latex-default-packages-alist
;              '("linktocpage,pdfstartview=FitH,colorlinks
; -linkcolor=black,anchorcolor=black,
; -citecolor=black,filecolor=blue,menucolor=black,urlcolor=blue"
;                "hyperref" nil)
;              t)
; #+END_SRC
;
; *** Load languages for source blocks
;
; Some rough collection of languages that are loaded for use in my everyday
; org-mode workflow.
;
; #+BEGIN_SRC emacs-lisp
; (org-babel-do-load-languages
;  'org-babel-load-languages
;  '((shell . t)
;    (python . t)))
; #+END_SRC
;
; In the same fashion, define the safe languages that require no explicit
; confirmation of being executed.
;
; #+BEGIN_SRC emacs-lisp
; (defun my-org-confirm-babel-evaluate (lang body)
;   (not (member lang '("emacs-lisp" "python" "sh"))))
;
; (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
; #+END_SRC

*** Native ~TAB~ in source blocks

This option makes ~TAB~ work as if the keystroke was issued in the code's major
mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

*** Display inline images

A small piece of elisp extracted from [[https://joy.pm/post/2017-09-17-a_graphviz_primer/][The Joy of Programming]] to properly
display inline images in org.

#+BEGIN_SRC emacs-lisp
(defun my/fix-inline-images ()
  (when org-inline-image-overlays
    (org-redisplay-inline-images)))

(add-hook 'org-babel-after-execute-hook 'my/fix-inline-images)
(setq-default org-image-actual-width 620)
#+END_SRC

; *** Set source blocks to export as listings
;
; This little snippets ensures that org will export the source blocks in the
; =lstlisting= environment and highlight the syntax when necessary.
;
; #+BEGIN_SRC emacs-lisp
; (require 'ox-latex)
; (add-to-list 'org-latex-packages-alist '("" "listings"))
; (add-to-list 'org-latex-packages-alist '("" "color"))
; #+END_SRC
;
; *** Open source blocks in the same window
;
; When editing source code in an ~org~ source block, we can open a new buffer to
; edit the code in its major mode. This option makes it use the same window
; instead of popping a new one.
;
; #+BEGIN_SRC emacs-lisp
; (setq org-src-window-setup 'current-window)
; #+END_SRC
;
; *** Set the directory
;
; I set my org-directory in Dropbox. In there is the agenda files as well.
;
; #+BEGIN_SRC emacs-lisp
; (setq org-directory "~/Dropbox/org")
;
; (defun org-file-path (filename)
;   "Return the absolute address of an org file, given its relative name."
;   (concat (file-name-as-directory org-directory) filename))
;
; (setq org-agenda-files (list (org-file-path "master.org")
;                              (org-file-path "agenda.org")))
; #+END_SRC
;
; *** Better RET
;
; While reading this post in [[http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/][the Kitchin Research Group website]], I stumbled into
; this package that allows a better behavior of ~RET~ in ~org-mode~.
;
; #+BEGIN_SRC emacs-lisp
; (use-package org-autolist
;   :ensure t
;   :delight
;   :config (add-hook 'org-mode-hook (lambda () (org-autolist-mode))))
; #+END_SRC
;
; *** Formatting functions
;
; I have defined several functions to help me format text using the org markup
; language. When I have selected text, I can use those keybindings to surround
; the text with the different signs.
;
; #+BEGIN_SRC emacs-lisp
; (defun org-mode-format-bold (&optional arg)
;   "Surround the selected text with asterisks (bold)"
;   (interactive "P")
;   (insert-pair arg ?\* ?\*))
;
; (defun org-mode-format-italics (&optional arg)
;   "Surround the selcted text with forward slashes (italics)"
;   (interactive "P")
;   (insert-pair arg ?\/ ?\/))
;
; (defun org-mode-format-tt (&optional arg)
;   "Surround the selcted text with virgules (monotype)"
;   (interactive "P")
;   (insert-pair arg ?\~ ?\~))
;
;
; (add-hook 'org-mode-hook
;           (lambda ()
;             (local-set-key (kbd "C-c f b") 'org-mode-format-bold)
;             (local-set-key (kbd "C-c f i") 'org-mode-format-italics)
;             (local-set-key (kbd "C-c f m") 'org-mode-format-tt)
;             (local-set-key (kbd "C-c f *") 'org-mode-format-bold)
;             (local-set-key (kbd "C-c f /") 'org-mode-format-italics)
;             (local-set-key (kbd "C-c f =") 'org-mode-format-tt)))
; #+END_SRC
;
; *** Keybinding for ~org-agenda~
;
; I like to have an easy access to the agenda, so I'll just bind it to ~C-c a~.
;
; #+BEGIN_SRC emacs-lisp
; (global-set-key (kbd "C-c a") 'org-agenda)
; #+END_SRC
;
** Graphical aspects
*** Use syntax highlight in source blocks

When writing source code on a block, if this variable is enabled it will use
the same syntax highlight as the mode supposed to deal with it.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

*** Enable ~org-bullets~

Enable ~org-bullets~ to make it clearer. Also, the defaults are maybe
a bit too much for me, so edit them.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :delight
  :config
  (progn
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
    (setq org-bullets-bullet-list
          '("◉" "◎" "○" "○" "○" "○"))))
#+END_SRC

*** Custom ellipsis

Also, I don't really like ~...~ to be the symbol for an ~org~ ellipsis. I
prefer to set something much more visual:

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ⤵")
#+END_SRC

*** Pretty symbols

This setting will make subscripts (~x_{subscript}~) and superscripts
(~x^{superscript}~) appear in ~org~ in a WYSIWYG fashion.

#+BEGIN_SRC emacs-lisp
(setq-default org-pretty-entities t)
#+END_SRC

*** LaTeX blocks

To preview latex fragments, we need some quick set up to obtain proper quality
to read it in a Retina display.

#+BEGIN_SRC emacs-lisp
(setq org-latex-create-formula-image-program 'dvisvgm)
#+END_SRC

; ** Spell checking
;
; Add spell checking by enabling ~flyspell~ in its buffers. The configuration for
; ~flyspell~ is above.
;
; #+BEGIN_SRC emacs-lisp
; (add-hook 'org-mode-hook 'flyspell-mode)
; ;(add-hook 'org-mode-hook 'flyspell-buffer)
; #+END_SRC
;
** ~org-ref~

~org-ref~ is a great package that enables a great deal of references and
shortcuts in ~org-mode~ when exporting to different formats like HTML or
LaTeX. The configuration can be a bit of a pain in the ass:

*** Basic setup and default dirs

We require the packages and set the default for the bibliography notes, the
main ~.bib~ bibliography and the directory where the PDFs can be downloaded to.

#+BEGIN_SRC emacs-lisp
;; (use-package org-ref-pdf
;;   :ensure t)

;; (use-package org-ref-url-utils
;;   :ensure t)

(use-package org-ref
  :ensure t
  :delight
  :config
  (progn
    (setq org-ref-bibliography-notes "~/Google Drive Personal/org/bibliography/notes.org"
          org-ref-default-bibliography '("~/Google Drive Personal/org/bibliography/main.bib")
          org-ref-pdf-directory "~/Google Drive Personal/org/bibliography/pdfs"
          org-latex-pdf-process
          '("pdflatex -interaction nonstopmode -output-directory %o %f"
            "bibtex %b"
            "pdflatex -interaction nonstopmode -output-directory %o %f"
            "pdflatex -interaction nonstopmode -output-directory %o %f"))))
#+END_SRC

We also make sure to create the directory if it does not exist

#+BEGIN_SRC emacs-lisp
(unless (file-exists-p org-ref-pdf-directory)
  (make-directory org-ref-pdf-directory t))
#+END_SRC

*** Set default key in Bibtex entries

When using tools like ~crossref-add-bibtex-entry~, we want a meaningful key to
be defined in the entries. I found this method in the ~org-ref~ config file.

#+BEGIN_SRC emacs-lisp
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC

; ** ~ditaa~
;
; ~ditaa~ is a command-line utility, packed with ~org~, that allows conversion
; from ascii art to bitmap. This is basically sorcery for taking notes. To enable
; it, we have to explicitly load it to ~babel~:
;
; #+BEGIN_SRC emacs-lisp
; (org-babel-do-load-languages
;  'org-babel-load-languages
;  '((ditaa . t)))
; #+END_SRC
;
; ** Diagrams using graphviz
;
; My personal setup for generating fast diagrams in org-mode. Super useful when
; one needs to take notes in class or other situations where a diagram is needed.
;
; #+BEGIN_SRC emacs-lisp
; (use-package graphviz-dot-mode
;   :ensure t)
;
; (org-babel-do-load-languages
;  'org-babel-load-languages
;  '((dot . t)))
;
; (defun my-org-confirm-babel-evaluate (lang body)
;   (not (member lang '("dot"))))
;
; (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
; #+END_SRC
;
; ** Export settings
; *** Open PDFs using the appropriate viewer
;
; I am not super fond of the default Emacs PDF viewer, so I prefer to set it to
; GNOME's default one, Evince.
;
; #+BEGIN_SRC emacs-lisp
; (add-hook 'org-mode-hook
;       '(lambda ()
;          (delete '("\\.pdf\\'" . default) org-file-apps)
;          (add-to-list 'org-file-apps '("\\.pdf\\'" . "evince %s"))))
; #+END_SRC
;
; *** IEEE export
;
; For class assignments and who-knows-what in the future, I was able to integrate
; a IEEE Conference template in org-mode export via Latex. To use it, just
; include the =IEEEtran= class in your org file. It has not been thoroughly
; tested, but its headers, index, abstract and general aesthetic works perfectly
; out of the box.
;
; #+BEGIN_SRC emacs-lisp
; (add-to-list 'org-latex-classes
;              '("IEEEtran" "\\documentclass[11pt]{IEEEtran}"
;                ("\\section{%s}" . "\\section*{%s}")
;                ("\\subsection{%s}" . "\\subsection*{%s}")
;                ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
;                ("\\paragraph{%s}" . "\\paragraph*{%s}")
;                ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
;              t)
; #+END_SRC
;
; *** Beamer export
;
; We need to manually enable the export to Beamer option.
;
; #+BEGIN_SRC emacs-lisp
; (use-package ox-beamer)
; #+END_SRC
;
; * Other Major Modes
; ** ~erc~
;
; ~erc~ is a IRC client for Emacs. It is a wonderful tool worth checking out, and
; requires really little configuration to make to be great.
;
; *** Hide messages from inactive people
;
; This snippet hides all the IRC messages that notify someone has joined, parted
; or quitted if that user has been inactive for more than half an hour.
;
; #+BEGIN_SRC emacs-lisp
; (setq erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
; (setq erc-lurker-threshold-time 1800)
; #+END_SRC
;
; *** Use the proper default nickname
;
; ~erc~ suggests a default nickname when logging in. ~agis~ is my username, if
; you want to set another one just change that argument.
;
; #+BEGIN_SRC emacs-lisp
; (setq erc-nick "agis")
; #+END_SRC
; ** ~w3m~
;
; ~w3m~ is a web browser. Yes, you read that right. No, it's not going to be a
; substitute of your regular browser, but it's handy to have a fast way to query
; things without going out of Emacs. It's super geeky, I know.
;
; #+BEGIN_SRC emacs-lisp
; (global-set-key (kbd "C-c w") 'w3m)
; #+END_SRC
;
; *** Set browser options
;
; Basically, making it the default browser from Emacs, enable the cookies and
; setting an Android agent to prevent clutter.
;
; #+BEGIN_SRC emacs-lisp
; ;; (setq browse-url-browser-function 'w3m-goto-url-new-session)
; (setq w3m-set-cookies t)
; (setq w3m-user-agent "Mozilla/5.0 (Linux; U; Android 2.3.3; zh-tw; HTC_Pyramid
;  Build/GRI40) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile
;  Safari/533.")
; #+END_SRC
;
; *** Giving permission to set cookies
;
; I like to explicitly give permission to my frequent places to set cookies.
;
; #+BEGIN_SRC emacs-lisp
; (setq w3m-cookie-accept-domains '("reddit.com"))
; #+END_SRC
;
; *** Reddit shortcut
;
; This function enables a shortcut that prompts the user for a subreddit, being
; r/emacs the default one.
;
; #+BEGIN_SRC emacs-lisp
; (defun reddit (subreddit)
;   "Opens the `subreddit' in w3m-new-session"
;   (interactive
;    (list
;     (read-string "Enter subreddit (default: r/emacs): " nil nil "emacs" nil)))
;   (browse-url (format "http://m.reddit.com/r/%s" subreddit))
;   )
; #+END_SRC
;
;
; TODO: In my current setup, the colors are incredibly aggressive.
;
; ** ~notmuch~
;
; This package allows to fetch and write emails from Emacs. Is it pushing a text
; editor too far? Maybe. Also, take into account that it is part of ~notmuch~ and
; it should be installed in your system.
;
; #+BEGIN_SRC emacs-lisp
; (use-package notmuch
;   :ensure t)
; #+END_SRC
